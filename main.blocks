<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="py6huE#!;j?QN.!(j.lL" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="|)oYl_x_iS+BFrtxeprY" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum REGISTER {" line1="    IODIRA = 0x00," line2="    IODIRB = 0x01," line3="    IPOLA = 0x02," line4="    IPOLB = 0x03," line5="    GPINTENA = 0x04," line6="    GPINTENB = 0x05," line7="    DEFVALA = 0x06," line8="    DEFVALB = 0x07," line9="    INTCONA = 0x08," line10="    INTCONB = 0x09," line11="    IOCONA = 0x0A," line12="    IOCONB = 0x0B," line13="    GPPUA = 0x0C," line14="    GPPUB = 0x0D," line15="    INTFA = 0x0E," line16="    INTFB = 0x0F," line17="    INTCAPA = 0x10," line18="    INTCAPB = 0x11," line19="    GPIOA = 0x12," line20="    GPIOB = 0x13," line21="    OLATA = 0x14," line22="    OLATB = 0x15" line23="}" numlines="24"></mutation><next><block type="typescript_statement" id="=:SfthZ4~%DY4d{HPWB@" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum PIN {" line1="    A = 0," line2="    B = 1" line3="}" numlines="4"></mutation><next><block type="typescript_statement" id="MWjUK{1Wt9,^1nb8Ao8." editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace xgp {" line1="    const xgp_ADDRESS = 0x20" line2="" line3="    const xgp_IODIRA = 0x00" line4="    const xgp_IPOLA = 0x02" line5="    const xgp_GPINTENA = 0x04" line6="    const xgp_DEFVALA = 0x06" line7="    const xgp_INTCONA = 0x08" line8="    const xgp_IOCONA = 0x0A" line9="    const xgp_GPPUA = 0x0C" line10="    const xgp_INTFA = 0x0E" line11="    const xgp_INTCAPA = 0x10" line12="    const xgp_GPIOA = 0x12" line13="    const xgp_OLATA = 0x14" line14="" line15="    const xgp_IODIRB = 0x01" line16="    const xgp_IPOLB = 0x03" line17="    const xgp_GPINTENB = 0x05" line18="    const xgp_DEFVALB = 0x07" line19="    const xgp_INTCONB = 0x09" line20="    const xgp_IOCONB = 0x0B" line21="    const xgp_GPPUB = 0x0D" line22="    const xgp_INTFB = 0x0F" line23="    const xgp_INTCAPB = 0x11" line24="    const xgp_GPIOB = 0x13" line25="    const xgp_OLATB = 0x15" line26="" line27="    let initialized = false" line28="" line29="    function i2cwrite(addr: number, reg: number, value: number): void {" line30="        let buf = pins.createBuffer(2);" line31="        buf[0] = reg;" line32="        buf[1] = value;" line33="        pins.i2cWriteBuffer(addr, buf);" line34="    }" line35="" line36="    function i2cread(addr: number, reg: number): number {" line37="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line38="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line39="        return val;" line40="    }" line41="" line42="    function initxgp(): void {" line43="        for (let regAddr = 0; regAddr &lt; 22; regAddr++) {" line44="            if (regAddr == 0 || regAddr == 1) {" line45="                i2cwrite(xgp_ADDRESS, regAddr, 0xFF);" line46="            }" line47="            else {" line48="                i2cwrite(xgp_ADDRESS, regAddr, 0x00);" line49="            }" line50="        }" line51="" line52="        //configue all PinA output" line53="        i2cwrite(xgp_ADDRESS, xgp_IODIRA, 0x00);" line54="" line55="        //configue all PinB input" line56="        i2cwrite(xgp_ADDRESS, xgp_IODIRB, 0xFF);" line57="        //configue all PinB pullUP" line58="        i2cwrite(xgp_ADDRESS, xgp_GPPUB, 0xFF);" line59="" line60="        initialized = true;" line61="    }" line62="" line63="" line64="    /**" line65="     *Read data from the register" line66="     * @param reg [0-21] register of xgp; eg: 0, 15, 23" line67="    */" line68="    //% blockId=ReadReg block=&quot;Read register |%reg| data&quot;" line69="    //% weight=65" line70="    export function ReadReg(reg: REGISTER): number {" line71="        let val2 = i2cread(xgp_ADDRESS, reg);" line72="        return val2;" line73="    }" line74="" line75="" line76="    /**" line77="     * WriteData to PinA or PinB" line78="     * @param pin [0-1] choose PinA or PinB; eg: 0, 1" line79="     * @param value [0-255] pulse of servo; eg: 128, 0, 255" line80="    */" line81="    //% blockId=WritePin block=&quot;Set P |%pin| value |%value|&quot;" line82="    //% weight=75" line83="    //% value.min=0 value.max=255" line84="    export function WritePin(pin: PIN, value: number): void {" line85="        if (!initialized) {" line86="            initxgp();" line87="        }" line88="        if (pin == 0) {" line89="            i2cwrite(xgp_ADDRESS, xgp_GPIOA, value);" line90="        }" line91="        else {" line92="            i2cwrite(xgp_ADDRESS, xgp_GPIOB, value);" line93="        }" line94="    }" line95="" line96="    /**" line97="     *ReadData From PinA or PinB " line98="     * @param pin [0-1] choose PinA or PinB; eg: 0, 1" line99="    */" line100="    //% blockId=ReadPin block=&quot;Read data from |%pin|&quot;" line101="    //% weight=85" line102="    export function ReadPin(pin: PIN): number {" line103="        if (!initialized) {" line104="            initxgp();" line105="        }" line106="        if (pin == 0) {" line107="            let val3 = i2cread(xgp_ADDRESS, xgp_GPIOA);" line108="            return val3;" line109="        }" line110="        else {" line111="            let val4 = i2cread(xgp_ADDRESS, xgp_GPIOB);" line112="            return val4;" line113="        }" line114="    }" line115="}" numlines="116"></mutation></block></next></block></next></block></statement></block></xml>